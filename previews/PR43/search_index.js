var documenterSearchIndex = {"docs":
[{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/#Docstrings","page":"API reference","title":"Docstrings","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [Interfaces]","category":"page"},{"location":"api/#Interfaces.Interfaces","page":"API reference","title":"Interfaces.Interfaces","text":"Interfaces\n\nA Julia package for specifying and testing interfaces (conditions verified by a set of methods applied to a type).\n\n\n\n\n\n","category":"module"},{"location":"api/#Interfaces.Arguments","page":"API reference","title":"Interfaces.Arguments","text":"Arguments{names,T}\n\nArguments(; kw...)\nArguments(nt::NamedTuple)\n\nA wrapper for a NamedTuple.\n\n\n\n\n\n","category":"type"},{"location":"api/#Interfaces.Interface","page":"API reference","title":"Interfaces.Interface","text":"Interface{Components}\n\nAbstract supertype for all Interfaces.jl interfaces.\n\nComponents is an Tuple of Symbol.\n\n\n\n\n\n","category":"type"},{"location":"api/#Interfaces.components","page":"API reference","title":"Interfaces.components","text":"components(::Type{<:Interface})\n\nReturns the components of the interface, as a NamedTuple of NamedTuple.\n\n\n\n\n\n","category":"function"},{"location":"api/#Interfaces.description","page":"API reference","title":"Interfaces.description","text":"description(::Type{<:Interface})\n\nReturns a String description of an interface.\n\n\n\n\n\n","category":"function"},{"location":"api/#Interfaces.implemented_trait-Union{Tuple{T}, Tuple{Type{T}, Any}} where T<:Interfaces.Interface","page":"API reference","title":"Interfaces.implemented_trait","text":"implemented_trait(T::Type{<:Interface}, obj)\nimplemented_trait(T::Type{<:Interface{Option}}, obj)\n\nProvides a single type for using interface implementation as a trait.\n\nReturns Implemented{T}() or NotImplemented{T}().\n\n\n\n\n\n","category":"method"},{"location":"api/#Interfaces.implements","page":"API reference","title":"Interfaces.implements","text":"implements(::Type{<:Interface}, obj)\nimplements(::Type{<:Interface{Options}}, obj)\n\nReturns whether an object implements an interface, as a Bool.\n\nobj can be an be an object or a Type.\n\nOptions can be a Symbol or a Tuple of Symbol passed to the type parameter of the Interface, to check if optional interfaces are implemented by the obj.\n\nWithout specifying Options, the return value specifies that at least  all the mandatory components of the interace are implemented.\n\n\n\n\n\n","category":"function"},{"location":"api/#Interfaces.optional_keys","page":"API reference","title":"Interfaces.optional_keys","text":"optional_keys(T::Type{<:Interface}, O::Type)\n\nGet the keys for the optional components of an Interface, as a tuple os Symbol.\n\n\n\n\n\n","category":"function"},{"location":"api/#Interfaces.requiredtype","page":"API reference","title":"Interfaces.requiredtype","text":"requiredtype(::Type{<:Interface})\n\nReturns the supertype required for all interface implementations.\n\n\n\n\n\n","category":"function"},{"location":"api/#Interfaces.test","page":"API reference","title":"Interfaces.test","text":"test(; kw...)\ntest(mod::Module; kw...)\ntest(::Type; kw...)\ntest(::Type{<:Interface}; kw...)\ntest(::Type{<:Interface}, mod::Module; kw...)\ntest(::Type{<:Interface}, type::Type, [test_objects]; kw...)\n\nTest if an interface is implemented correctly, returning true or false.\n\nThere are a number of ways to select implementations to test:\n\nWith no arguments, test all defined Interfaces currenty imported.\nIf a Module is passed, all Interface implementations defined in it will be tested.    This is probably the best option to put in package tests.\nIf only an Interface is passed, all implementations of it are tested.\nIf only a Type is passed, all interfaces it implements are tested.\nIf both a Module and an Interface are passed, test the intersection.   of implementations of the Interface for the Module.\nIf an Interface and Type are passed, the implementation for that type will be tested.\n\nIf no interface type is passed, Interfaces.jl will find all the interfaces available and test them.\n\n\n\n\n\n","category":"function"},{"location":"api/#Interfaces.test_objects","page":"API reference","title":"Interfaces.test_objects","text":"test_objects(T::Type{<:Interface}, O::Type)\n\nGet the test object(s) for type O and interface T.\n\n\n\n\n\n","category":"function"},{"location":"api/#Interfaces.@implements-Tuple{Any, Any, Any}","page":"API reference","title":"Interfaces.@implements","text":"@implements(interface, objtype, test_objects)\n\nDeclare that an interface implements an interface, or multipleinterfaces.\n\nThe macro can only be used once per module for any one type. To define multiple interfaces a type implements, combine them in square brackets.\n\nExample\n\nHere we implement the IterationInterface for Base julia, indicating with (:indexing, :reverse) that our object can be indexed and works with Iterators.reverse:\n\nusing BaseInterfaces, Interfaces\n@implements BaseInterfaces.IterationInterface{(:indexing,:reverse)} MyObject [MyObject(1:10), MyObject(10:-1:1)]\n\n\n\n\n\n","category":"macro"},{"location":"api/#Interfaces.@interface-NTuple{4, Any}","page":"API reference","title":"Interfaces.@interface","text":"@interface(interfacename, components, [description])\n\nDefine an interface that can apply to types <: Any.\n\ncomponents = (\n    mandatory = (\n        length = x -> length(x) = prod(size(x)),\n        ndims = x -> ndims(x) = length(size(x)),\n    ),\n    optional = (;)\n)\ndescription = \"A description of the interface\"\n\n@interface MyInterface Any components description\n\n\n\n\n\n","category":"macro"},{"location":"api/#Index","page":"API reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"basic/","page":"Basic","title":"Basic","text":"EditURL = \"../../test/basic.jl\"","category":"page"},{"location":"basic/#Basic","page":"Basic","title":"Basic","text":"","category":"section"},{"location":"basic/","page":"Basic","title":"Basic","text":"Here's an example of single-argument interface using animals, and the implementation of a duck.","category":"page"},{"location":"basic/#Definition","page":"Basic","title":"Definition","text":"","category":"section"},{"location":"basic/","page":"Basic","title":"Basic","text":"First we define the interface methods, and a list of mandatory and optional properties of the interface, with conditions, using the @interface macro.","category":"page"},{"location":"basic/","page":"Basic","title":"Basic","text":"The @interface macro takes three arguments:","category":"page"},{"location":"basic/","page":"Basic","title":"Basic","text":"The name of the interface, which should usully end with \"Interface\"\nThe mandatory and optional components of the interface written as a NamedTuple, with functions or tuple of functions that test them.\nThe interface docstring (the interface is represented as a type)","category":"page"},{"location":"basic/","page":"Basic","title":"Basic","text":"module Animals\n\nusing Interfaces\n\nabstract type Animal end\n\nfunction age end\nfunction walk end\nfunction talk end\nfunction dig end\n\ncomponents = (\n    mandatory = (\n        age = (\n            \"all animals have a `Real` age\" => x -> age(x) isa Real,\n            \"all animals have an age larger than zero\" => x -> age(x) >= 0,\n        ),\n    ),\n    optional = (\n        walk = \"this animal can walk\" => x -> walk(x) isa String,\n        talk = \"this animal can talk\" => x -> talk(x) isa Symbol,\n        dig = \"this animal can dig\" => x -> dig(x) isa String,\n    )\n)\n\ndescription = \"\"\"\nDefines a generic interface for animals to do the things they do best.\n\"\"\"\n\n@interface AnimalInterface Animal components description\n\nend;\nnothing #hide","category":"page"},{"location":"basic/#Implementation","page":"Basic","title":"Implementation","text":"","category":"section"},{"location":"basic/","page":"Basic","title":"Basic","text":"using Interfaces, Test","category":"page"},{"location":"basic/","page":"Basic","title":"Basic","text":"Now we implement the AnimalInterface, for a Duck.","category":"page"},{"location":"basic/","page":"Basic","title":"Basic","text":"struct Duck <: Animals.Animal\n    age::Int\nend\n\nAnimals.age(duck::Duck) = duck.age\nAnimals.walk(::Duck) = \"waddle\"\nAnimals.talk(::Duck) = :quack","category":"page"},{"location":"basic/","page":"Basic","title":"Basic","text":"We then test that the interface is correctly implemented","category":"page"},{"location":"basic/","page":"Basic","title":"Basic","text":"ducks = [Duck(1), Duck(2)]\nInterfaces.test(Animals.AnimalInterface, Duck, ducks)","category":"page"},{"location":"basic/","page":"Basic","title":"Basic","text":"As well as two optional methods","category":"page"},{"location":"basic/","page":"Basic","title":"Basic","text":"Interfaces.test(Animals.AnimalInterface{(:walk,:talk)}, Duck, ducks)","category":"page"},{"location":"basic/","page":"Basic","title":"Basic","text":"Finally we declare it, so that the information can be used in static dispatch.","category":"page"},{"location":"basic/","page":"Basic","title":"Basic","text":"The @implements macro takes two arguments.","category":"page"},{"location":"basic/","page":"Basic","title":"Basic","text":"The interface type, with a tuple of optional components in its first type parameter.\nThe type for which the interface is implemented.","category":"page"},{"location":"basic/","page":"Basic","title":"Basic","text":"@implements Animals.AnimalInterface{(:walk,:talk)} Duck [Duck(1), Duck(2)]","category":"page"},{"location":"basic/","page":"Basic","title":"Basic","text":"Now let's see what happens when the interface is not correctly implemented.","category":"page"},{"location":"basic/","page":"Basic","title":"Basic","text":"struct Chicken <: Animals.Animal end","category":"page"},{"location":"basic/","page":"Basic","title":"Basic","text":"As expected, the tests fail","category":"page"},{"location":"basic/","page":"Basic","title":"Basic","text":"chickens = [Chicken()]\ntry\n    Interfaces.test(Animals.AnimalInterface, Chicken, chickens)\ncatch e\n    print(e)\nend\n\n\n\n    @test Interfaces.test(Duck) == true # Test all implemented interfaces for Duck\n    @test Interfaces.test(Animals.AnimalInterface) == true # Test all implemented types for AnimalInterface","category":"page"},{"location":"basic/","page":"Basic","title":"Basic","text":"","category":"page"},{"location":"basic/","page":"Basic","title":"Basic","text":"This page was generated using Literate.jl.","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"EditURL = \"../../test/advanced.jl\"","category":"page"},{"location":"advanced/#Advanced","page":"Advanced","title":"Advanced","text":"","category":"section"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"Here's an example of multi-argument interface using groups. For mathematicians, a group is just a set of objects where you can perform multiplication and inversion, such that an element multiplies by its inverse yields a neutral element.","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"warning: Warning\nThis functionality is still experimental and might evolve in the future. If you have feedback about it, open an issue to help us improve it!","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"using Interfaces","category":"page"},{"location":"advanced/#Definition","page":"Advanced","title":"Definition","text":"","category":"section"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"Unlike the AnimalInterface, this example involves functions with more than one argument. Such arguments need to be passed to the interface testing code, which means the interface definition must take them into account as well.","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"For technical reasons, we provide a type called Arguments that you should use for this purpose. It behaves exactly like a NamedTuple but enables easier dispatch.","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"module Group\n\nusing Interfaces\n\nfunction neutral end\nfunction multiplication end\nfunction inversion end\n\n@interface GroupInterface Number (\n    mandatory = (;\n        neutral_check = (\n            \"neutral stable\" => a::Arguments -> neutral(typeof(a.x)) isa typeof(a.x),\n        ),\n        multiplication_check = (\n            \"multiplication stable\" => a::Arguments -> multiplication(a.x, a.y) isa typeof(a.x),\n        ),\n        inversion_check = (\n            \"inversion stable\" => a::Arguments -> inversion(a.x) isa typeof(a.x),\n            \"inversion works\" => a::Arguments -> multiplication(a.x, inversion(a.x)) ≈ neutral(typeof(a.x)),\n        ),\n    ),\n    optional = (;),\n) \"\"\"\nA group is a set of elements with a neutral element where you can perform multiplications and inversions.\n\nThe conditions checking the interface accept an `Arguments` object with two fields named `x` and `y`.\nThe type of the first field `x` must be the type you wish to declare as implementing `GroupInterface`.\n\"\"\"\n\nend;\nnothing #hide","category":"page"},{"location":"advanced/#Implementation","page":"Advanced","title":"Implementation","text":"","category":"section"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"Let's try to see if our favorite number types do indeed behave like a group.","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"Group.neutral(::Type{N}) where {N<:Number} = one(N)\nGroup.multiplication(x::Number, y::Number) = x * y\nGroup.inversion(x::Number) = inv(x)","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"First, we check it for floating point numbers, giving a list of Arguments objects with the proper fields to the test function.","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"float_pairs = [Arguments(x = 2.0, y = 1.0)]\nInterfaces.test(Group.GroupInterface, Float64, float_pairs)","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"We can thus declare proudly","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"@implements Group.GroupInterface Float64 [Arguments(x = 2.0, y = 1.0)]","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"Now we check it for integer numbers. The reason it fails is because for an integer x, the inverse 1/x is no longer an integer! Thus integer numbers are not a multiplicative group.","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"int_pairs = [Arguments(x = 2, y = 1)]\nInterfaces.test(Group.GroupInterface, Int, int_pairs)","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"What happens if we give an input whose field types (Int) are not coherent with the type we are testing (Float64)?","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"try\n    Interfaces.test(Group.GroupInterface, Float64, int_pairs)\ncatch e\n    print(e.msg)\nend","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"In summary, there are two things to remember:","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"The anonymous functions in the interface conditions of Interfaces.@interface should accept a single object of type Arguments and then work with its named fields. These fields should be listed in the docstring.\nThe list of objects passed to Interface.test must all be of type Arguments, with the right named fields. At least one field must have the type you are testing.","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"","category":"page"},{"location":"advanced/","page":"Advanced","title":"Advanced","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"EditURL = \"https://github.com/rafaqz/Interfaces.jl/blob/main/README.md\"","category":"page"},{"location":"#Interfaces","page":"Home","title":"Interfaces","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Macros for defining the required behaviours of Julia interfaces, and stating that an object implements them.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The goal is to get as much as possible out of defining an interface, specifically:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Traits: All @implements declarations produce compile-time traits that can be checked by other packages - for the whole interface and all of it's optional components.\nTests: @implements declarations should be tested in package tests.\nDocs: interface documentation can be inserted into trait documentation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the IterationInterface in BaseInterfaces.jl (a subpackage of this package) or the documentation for examples of @interface and @implements.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note: the syntax here is likely to change as we work out the best ways to define interfaces","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you think it should behave differently or there is better syntax, please make an issue.","category":"page"},{"location":"baseinterfaces/#BaseInterfaces-reference","page":"BaseInterfaces.jl reference","title":"BaseInterfaces reference","text":"","category":"section"},{"location":"baseinterfaces/#Docstrings","page":"BaseInterfaces.jl reference","title":"Docstrings","text":"","category":"section"},{"location":"baseinterfaces/","page":"BaseInterfaces.jl reference","title":"BaseInterfaces.jl reference","text":"Modules = [BaseInterfaces]","category":"page"},{"location":"baseinterfaces/#BaseInterfaces.ArrayInterface","page":"BaseInterfaces.jl reference","title":"BaseInterfaces.ArrayInterface","text":"    ArrayInterface\n\nAn Interfaces.jl Interface with mandatory components (:eltype, :ndims, :size, :getindex, :indexstyle) and optional components (:logical, :setindex!, :similar_type, :similar_eltype, :similar_size, :similar_eltype_size).\n\nBase Julia AbstractArray interface\n\n\n\n\n\n","category":"type"},{"location":"baseinterfaces/#BaseInterfaces.DictInterface","page":"BaseInterfaces.jl reference","title":"BaseInterfaces.DictInterface","text":"    DictInterface\n\nAn Interfaces.jl Interface with mandatory components (:iterate, :eltype, :keytype, :valtype, :keys, :values, :getindex) and optional components (:setindex!,).\n\nAbstractDict interface requires Arguments, with d = the_dict mandatory, and when setindex is needed, k = any_valid_key_not_in_d, v = any_valid_val\n\n\n\n\n\n","category":"type"},{"location":"baseinterfaces/#BaseInterfaces.IterationInterface","page":"BaseInterfaces.jl reference","title":"BaseInterfaces.IterationInterface","text":"    IterationInterface\n\nAn Interfaces.jl Interface with mandatory components (:iterate, :isiterable, :eltype, :size, :in) and optional components (:reverse, :indexing).\n\nAn interface for Base Julia iteration\n\n\n\n\n\n","category":"type"},{"location":"baseinterfaces/#BaseInterfaces.SetInterface","page":"BaseInterfaces.jl reference","title":"BaseInterfaces.SetInterface","text":"    SetInterface\n\nAn Interfaces.jl Interface with mandatory components (:isempty, :eltype, :length, :iteration, :in) and optional components (:copy, :empty, :hasfastin, :setdiff, :intersect, :union, :copymutable, :emptymutable, :empty!, :delete!, :push!, :sizehint!).\n\nThe AbstractSet interface\n\n\n\n\n\n","category":"type"},{"location":"baseinterfaces/#Index","page":"BaseInterfaces.jl reference","title":"Index","text":"","category":"section"},{"location":"baseinterfaces/","page":"BaseInterfaces.jl reference","title":"BaseInterfaces.jl reference","text":"","category":"page"}]
}
